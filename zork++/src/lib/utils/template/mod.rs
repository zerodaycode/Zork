pub mod resources;

use crate::config_file::compiler::CppCompiler;
use crate::utils;
use color_eyre::eyre::{bail, Context};
use color_eyre::Result;
use log::info;
use std::path::Path;
use std::process::Command;

/// Generates a new C++ standarized empty base project
/// with a pre-designed structure to organize the
/// user code in a modern fashion way.
///
/// Base template for the project files and folders:
///    - ./ifc/<project_name>
///        - math.<extension>
///    - ./src/<project_name>
///       - math.<extension>
///       - math2.<extension>
///    - main.cpp
///    - test
///    - dependencies
pub fn create_templated_project(
    project_name: &str,
    git: bool,
    compiler: CppCompiler,
) -> Result<()> {
    let project_root = Path::new(&project_name);
    info!("Creating the autogenerated template project");

    let path_ifc = project_root.join("ifc");
    let path_src = project_root.join("src");
    let path_test = project_root.join("test");
    let path_dependencies = project_root.join("deps");

    check_project_root_available(project_root)?;

    utils::fs::create_directory(project_root)?;
    utils::fs::create_directory(&path_ifc)?;
    utils::fs::create_directory(&path_src)?;
    utils::fs::create_directory(&path_test)?;
    utils::fs::create_directory(&path_dependencies)?;

    utils::fs::create_file(
        &path_ifc,
        &format!("{}.{}", "math", compiler.get_default_module_extension()),
        resources::IFC_MOD_FILE.as_bytes(),
    )?;
    utils::fs::create_file(
        &path_src,
        "main.cpp", // TODO from constants
        resources::MAIN.as_bytes(),
    )?;
    utils::fs::create_file(&path_src, "math.cpp", resources::SRC_MOD_FILE.as_bytes())?;
    utils::fs::create_file(&path_src, "math2.cpp", resources::SRC_MOD_FILE_2.as_bytes())?;

    // TODO The replaces must dissapear in the next PR
    let mut zork_conf = resources::CONFIG_FILE
        .replace("<project_name>", project_name)
        .replace("<autog_test>", project_name)
        .replace("<autogenerated_executable>", project_name);

    if cfg!(windows) {
        zork_conf = zork_conf.replace("libcpp", "stdlib")
    }
    utils::fs::create_file(
        project_root,
        utils::constants::CONFIG_FILE_NAME,
        zork_conf.as_bytes(),
    )?;

    if git {
        initialize_git_repository(project_root)?
    }

    Ok(())
}

fn check_project_root_available(project_root: &Path) -> Result<()> {
    if !project_root.exists() {
        // if it doesn't exist, there is nothing that would be overwritten
        return Ok(());
    }

    if !is_empty_directory(project_root)? {
        bail!("Directory {project_root:?} is not empty")
    }

    Ok(())
}

fn is_empty_directory(path: &Path) -> Result<bool> {
    if !path.is_dir() {
        return Ok(false);
    }

    let is_empty = path
        .read_dir()
        .with_context(|| format!("Directory {path:?} is not readable"))?
        .next()
        .is_none();

    Ok(is_empty)
}

fn initialize_git_repository(project_root: &Path) -> Result<()> {
    let exit_status = Command::new("git")
        .current_dir(project_root)
        .arg("init")
        .spawn()
        .with_context(|| "Could not run \"git init\"")?
        .wait()
        .with_context(|| "An error occurred while waiting for \"git init\" to finish")?;

    match exit_status.code() {
        Some(0) => {}
        None => bail!("Process \"git init\" was terminated by external signal"),
        Some(error_code) => bail!("Process \"git init\" returned {}", error_code),
    };

    Ok(())
}

#[cfg(test)]
mod tests {
    use color_eyre::Result;

    use crate::config_file::compiler::CppCompiler;
    use crate::utils::test;

    #[test]
    fn test_create_if_root_not_empty() -> Result<()> {
        test::in_temp_dir(|temp| {
            const PROJECT_NAME: &str = "example";

            let project_path = temp.join(PROJECT_NAME);
            let dummy_path = project_path.join("dummy.txt");

            std::fs::create_dir(project_path)?;
            std::fs::File::create(dummy_path)?;

            let result = super::create_templated_project(PROJECT_NAME, false, CppCompiler::CLANG);
            assert!(
                result.is_err(),
                "The project was created, even though the project root is not empty"
            );

            Ok(())
        })
    }
}
